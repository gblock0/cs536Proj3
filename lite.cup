/***
 *
 * This Is A Java CUP Specification For CSX-lite, a Small Subset
 * of The CSX Language, used In CS536
 * Extend this specification to handle all of CSX.
 *
 ***/

/* Preliminaries to set up and use the scanner.  */

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),  
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal CSXIdentifierToken     IDENTIFIER; 
terminal CSXIntLitToken         INTLIT;
terminal CSXStringLitToken      STRLIT;
terminal CSXCharLitToken        CHARLIT;
terminal CSXToken               LPAREN, RPAREN, ASG, LBRACE, RBRACE, LBRACKET, SEMI, COR;
terminal CSXToken               GT, CAND, LT, TIMES, COMMA, GEQ,  INCREMENT, DECREMENT;
terminal CSXToken               CCOM, SLASH,  LEQ, RBRACKET, COLON, PLUS, MINUS, EQ, NOTEQ;
terminal CSXToken               rw_IF, rw_BREAK, rw_CONTINUE, rw_TRUE, rw_ELSE, rw_FALSE, rw_PRINT, rw_WHILE, rw_CHAR;
terminal CSXToken               rw_RETURN, rw_READ, rw_CLASS, rw_CONST, rw_VOID, rw_INT, rw_BOOL;

/* Non terminals */
non terminal classNode               prog;  
non terminal memberDeclsOption		 memberdecls;
non terminal fieldDeclsOption        fielddecls;
non terminal methodDeclsOption       methoddecls;
non terminal Symbol                  optionalSemi;
non terminal methodDeclNode          methoddecl;
non terminal argDeclsOption          argdecls;
non terminal argDeclNode             argdecl;
non terminal declNode                fielddecl;
non terminal stmtsOption             stmts;
non terminal stmtNode                stmt;
non terminal typeNodeOption          type;
non terminal argsNodeOption          args;
non terminal readNodeOption          readlist;
non terminal printNodeOption         printlist;
non terminal exprNode                exp;
non terminal exprNode                term;
non terminal exprNode                factor;
non terminal exprNode                pri;
non terminal unaryOpNode             unary;
non terminal exprNode                unit; 
non terminal exprNode                name;
non terminal identNode               ident;
non terminal intLitNode              intliteral;




start with prog;

prog		::= rw_CLASS:c ident:i LBRACE memberdecls:m  RBRACE
			 {: RESULT=
				new csxLiteNode(f, s, l.linenum, l.colnum); :}	
		;
		
fielddecls
   			 ::=   fielddecl:f1 fielddecls:f2 
				 {: RESULT=
					new fieldDeclsNode(f1,f2, f1.linenum,f1.colnum); :}	
   			 |
				 {: RESULT=
					fieldDeclsNode.NULL; :}	
    		;
fielddecl
   			 ::= type:t     ident:i      SEMI 
				 {: RESULT=
					new varDeclNode(i,t,exprNode.NULL, t.linenum,t.colnum); :}	
    		;
    		
type
   			 ::= rw_INT:t
	 			{:
	  				 RESULT=new intTypeNode(t.linenum, t.colnum);
         		:}	
    		 |   rw_BOOL:t
				 {:
	  				 RESULT=new boolTypeNode(t.linenum, t.colnum);
         		:}	
    		; 
    		
stmts		::= stmt:s1  stmts:s2
			 {: RESULT=
			new stmtsNode(s1,s2,s1.linenum,s1.colnum);
			 :}	
		| 
			 {: RESULT= stmtsNode.NULL; :} 
		;
stmt		::= ident:id ASG exp:e SEMI
			 {: RESULT=
			new asgNode(new nameNode(id,id.linenum,id.colnum),e,id.linenum,id.colnum);
			 :}	

		| rw_IF:i LPAREN exp:e RPAREN  stmt:s
			 {:
			 RESULT=new ifThenNode(e,s, i.linenum,i.colnum); :}	
						
		|   LBRACE:l fielddecls:f stmts:s RBRACE optionalSemi
	 		{:
	  			 RESULT=new blockNode(f,s, l.linenum, l.colnum);
        	 :}	
        ;
         
exp		::= exp:leftval PLUS:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.PLUS,rightval,op.linenum,op.colnum); :}	
		| exp:leftval MINUS:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.MINUS,rightval,op.linenum,op.colnum); :}
		| unit:leftval EQ:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.EQ,rightval,op.linenum,op.colnum); :}	
		| unit:leftval NOTEQ:op unit:rightval
			 {: RESULT=new binaryOpNode(leftval,sym.NOTEQ,rightval,op.linenum,op.colnum); :}
	    
		|   unit:u
			{: RESULT = u; :}
		;
unit    ::=	
            LPAREN exp:e RPAREN 
	   		 {: RESULT = e; :}
        |  ident:i		
			 {: RESULT = i; :}
		 | intliteral:l
	  		  {: RESULT = l; :}
		;
ident		::= IDENTIFIER:i
			 {: RESULT = new identNode(i.identifierText,
									   i.linenum,i.colnum); :}	
		;
		
intliteral
   ::= INTLIT:i
	 {: RESULT = new intLitNode(i.intValue, i.linenum,i.colnum);
         :}	
    ;
		
optionalSemi
   		 ::= SEMI
   		 |
   		 ;
